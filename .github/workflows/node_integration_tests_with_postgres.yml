name: Integration & E2E Tests

on:
  workflow_call:
    inputs:
      node_version_file:
        description: "setup-node reads Node version from here"
        required: false
        type: string
        default: ".nvmrc"

permissions:
  contents: read

jobs:
  integration-tests:
    name: integration tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U postgres -d postgres"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=20
      localstack:
        image: localstack/localstack:latest
        ports:
          - 4566:4566
        env:
          SERVICES: s3,sqs,sns
      wiremock:
        image: wiremock/wiremock:2.35.0
        ports:
          - 8099:8080
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379

    env:
      # AWS / endpoints
      AWS_DEFAULT_REGION: eu-west-2
      AWS_ACCESS_KEY_ID: foobar
      AWS_SECRET_ACCESS_KEY: foobar
      LS: http://127.0.0.1:4566

    steps:
      - uses: actions/checkout@v4

      - name: Wait for services
        run: |
          for i in {1..60}; do pg_isready -h 127.0.0.1 -p 5432 -U postgres -d postgres && break; sleep 1; done
          curl -sfS --retry 20 --retry-connrefused --retry-delay 2 "$LS/_localstack/health" || exit 1
          curl -sfS --retry 20 --retry-connrefused --retry-delay 2 "http://127.0.0.1:8099/__admin" || exit 1

      - name: Install jq & psql client
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq postgresql-client

      - name: Setup AWS CLI
        run: |
          python3 -m pip install --user --upgrade pip
          python3 -m pip install --user "awscli==1.*"
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Create sample dashboard file (used for uploads)
        run: |
          # exact content, no trailing newline
          printf 'dashboard' > dashboard-file.txt

      # ==== AWS population (mirrors your script) ====
      - name: Seed LocalStack (S3 + SQS)
        run: |
          set -euo pipefail
          # queue: audit_event_queue
          aws --endpoint-url="$LS" sqs create-queue --queue-name audit_event_queue || true

          # bucket: wmt-web + five objects under generated-dashboards/
          aws --endpoint-url="$LS" s3api create-bucket \
            --bucket wmt-web \
            --region "$AWS_DEFAULT_REGION" \
            --create-bucket-configuration LocationConstraint="$AWS_DEFAULT_REGION" || true

          for ts in 20210729062147 20210730062147 20210731062147 20210801062147 20210802062147; do
            aws --endpoint-url="$LS" s3api put-object \
              --bucket wmt-web \
              --key generated-dashboards/dashboard_${ts}.txt \
              --body dashboard-file.txt
          done

      # (kept from your previous flow) start workload container and wait for schema
      - name: Start hmpps_workload container
        run: |
          docker run -d --name hmpps_workload \
            --add-host=host.docker.internal:host-gateway \
            -e SPRING_PROFILES_ACTIVE=dev,docker \
            -e DATABASE_USERNAME=postgres \
            -e DATABASE_PASSWORD=postgres \
            -e DATABASE_ENDPOINT=host.docker.internal:5432 \
            -e HMPPS_SQS_LOCALSTACK_URL=http://host.docker.internal:4566 \
            ghcr.io/ministryofjustice/hmpps-workload:latest \
            /bin/sh -lc 'sleep 10 && java -javaagent:/app/agent.jar -jar /app/app.jar'

      - name: Wait for DB schema
        env:
          PGPASSWORD: postgres
        run: |
          for i in {1..120}; do
            psql -h 127.0.0.1 -U postgres -d postgres -tAc "SELECT 1 FROM information_schema.tables WHERE table_name='flyway_schema_history'" | grep -q 1 && exit 0
            sleep 2
          done
          echo "Schema not ready in time"; docker logs hmpps_workload || true; exit 1

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Install deps
        run: npm ci --no-audit

      - name: Run integration tests
        env:
          DATABASE_SERVER: 127.0.0.1
          DATABASE_USERNAME: postgres
          DATABASE_PASSWORD: postgres
          DATABASE: postgres
          DATABASE_PORT: "5432"
          DATABASE_SSL: "false"
        run: npm run integration-test

  e2e-tests:
    name: e2e tests
    needs: integration-tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U postgres -d postgres"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=20
      localstack:
        image: localstack/localstack:latest
        ports:
          - 4566:4566
        env:
          SERVICES: s3,sqs,sns
      wiremock:
        image: wiremock/wiremock:2.35.0
        ports:
          - 8099:8080
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379

    env:
      AWS_DEFAULT_REGION: eu-west-2
      AWS_ACCESS_KEY_ID: foobar
      AWS_SECRET_ACCESS_KEY: foobar
      LS: http://127.0.0.1:4566

      APP_PORT: "3000"
      BASE_URL: http://127.0.0.1:3000
      WIREMOCK_URL: http://127.0.0.1:8099
      CHROME_BIN: /usr/bin/google-chrome

    steps:
      - uses: actions/checkout@v4

      - name: Wait for services
        run: |
          for i in {1..60}; do pg_isready -h 127.0.0.1 -p 5432 -U postgres -d postgres && break; sleep 1; done
          curl -sfS --retry 30 --retry-connrefused --retry-delay 2 "$LS/_localstack/health" || exit 1
          curl -sfS --retry 30 --retry-connrefused --retry-delay 2 "http://127.0.0.1:8099/__admin" || exit 1

      - name: Setup AWS CLI + jq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq
          python3 -m pip install --user --upgrade pip
          python3 -m pip install --user "awscli==1.*"
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Seed LocalStack (queue + sample dashboards)
        run: |
          set -euo pipefail
          aws --endpoint-url="$LS" sqs create-queue --queue-name audit_event_queue || true
          aws --endpoint-url="$LS" s3api create-bucket \
            --bucket wmt-web \
            --region "$AWS_DEFAULT_REGION" \
            --create-bucket-configuration LocationConstraint="$AWS_DEFAULT_REGION" || true
          printf 'dashboard' > dashboard-file.txt
          for ts in 20210729062147 20210730062147 20210731062147 20210801062147 20210802062147; do
            aws --endpoint-url="$LS" s3api put-object \
              --bucket wmt-web \
              --key generated-dashboards/dashboard_${ts}.txt \
              --body dashboard-file.txt
          done

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Install deps
        run: npm ci --no-audit

      - name: Install Google Chrome (for WDIO)
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y wget gpg
          wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo gpg --dearmor -o /usr/share/keyrings/google-linux-signing-keyring.gpg
          echo "deb [arch=amd64 signed-by=/usr/share/keyrings/google-linux-signing-keyring.gpg] http://dl.google.com/linux/chrome/deb/ stable main" | sudo tee /etc/apt/sources.list.d/google-chrome.list >/dev/null
          sudo apt-get update
          sudo apt-get install -y google-chrome-stable
          google-chrome --version

      - name: Install psql client
        run: |
          sudo apt-get update -y
          sudo apt-get install -y postgresql-client

      - name: Start hmpps_workload container
        run: |
          docker run -d --name hmpps_workload \
            --add-host=host.docker.internal:host-gateway \
            -e SPRING_PROFILES_ACTIVE=dev,docker \
            -e DATABASE_USERNAME=postgres \
            -e DATABASE_PASSWORD=postgres \
            -e DATABASE_ENDPOINT=host.docker.internal:5432 \
            -e HMPPS_SQS_LOCALSTACK_URL=http://host.docker.internal:4566 \
            ghcr.io/ministryofjustice/hmpps-workload:latest \
            /bin/sh -lc 'sleep 10 && java -javaagent:/app/agent.jar -jar /app/app.jar'

      - name: Wait for DB schema
        env:
          PGPASSWORD: postgres
        run: |
          for i in {1..120}; do
            psql -h 127.0.0.1 -U postgres -d postgres -tAc "SELECT 1 FROM information_schema.tables WHERE table_name='flyway_schema_history'" | grep -q 1 && exit 0
            echo "Waiting for Flyway schema... ($i/120)"
            sleep 2
          done
          echo "Schema not ready in time"; docker logs hmpps_workload || true; exit 1

      - name: Build assets
        run: npm run build

      - name: Start app (start-dev on :3000)
        env:
          PORT: 3000
          REDIS_HOST: 127.0.0.1
          REDIS_PORT: "6379"
          REDIS_URL: redis://127.0.0.1:6379
        run: |
          set -euo pipefail
          # start-dev exports feature.env then starts the server
          nohup npm run start-dev >/tmp/app.log 2>&1 &
          for i in {1..60}; do
            if curl -fsS http://127.0.0.1:3000/ >/dev/null; then
              echo "App ready on :3000"
              break
            fi
            sleep 2
          done
          echo '--- app log tail ---'
          tail -n 200 /tmp/app.log || true

      - name: Load WireMock mappings
        run: npm run post-wiremock-mappings


      - name: Run E2E (npm run test-e2e)
        env:
          BASE_URL: ${{ env.BASE_URL }}
          DATABASE_SERVER: 127.0.0.1
          DATABASE_USERNAME: postgres
          DATABASE_PASSWORD: postgres
          DATABASE: postgres
          DATABASE_PORT: "5432"
          DATABASE_SSL: "false"
          CHROME_BIN: ${{ env.CHROME_BIN }}
        run: |
          set -euo pipefail
          # mirror: "export $(cat feature.env) && npm run clean-dev-data && npm run seed-dev-data && wdio test/e2e.conf.js && npm run clean-dev-data"
          export $(cat feature.env | xargs)
          npm run clean-dev-data
          npm run seed-dev-data
          npx wdio test/e2e.conf.js --workers 1
          npm run clean-dev-data

      - name: Upload E2E artifacts (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-artifacts
          path: |
            ./screenshots
            ./videos
            ./wdio-*.log
          if-no-files-found: ignore
